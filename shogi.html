<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>å°†æ£‹ã‚²ãƒ¼ãƒ </title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-user-select: none;
      user-select: none;
    }
    body {
      font-family: 'Hiragino Kaku Gothic ProN', 'ãƒ¡ã‚¤ãƒªã‚ª', sans-serif;
      background: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    h1 {
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      margin-bottom: 10px;
      font-size: 1.5rem;
    }
    .status {
      color: #fff;
      font-size: 1.2rem;
      margin-bottom: 10px;
      padding: 8px 16px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .captured-area {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      padding: 8px;
      background: #DEB887;
      border-radius: 8px;
      min-height: 50px;
      min-width: 280px;
      justify-content: center;
      border: 2px solid #8B4513;
    }
    .captured-area.enemy {
      background: #D2B48C;
    }
    .captured-label {
      width: 100%;
      text-align: center;
      font-size: 0.9rem;
      color: #5D4037;
      margin-bottom: 5px;
    }
    .captured-piece {
      width: 32px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      background: #FFEFD5;
      border: 1px solid #8B4513;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .captured-piece.enemy-piece {
      transform: rotate(180deg);
    }
    .captured-piece:hover {
      background: #FFE4B5;
    }
    .captured-piece.selected {
      background: #90EE90;
      box-shadow: 0 0 10px #32CD32;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 1px;
      background: #2C1810;
      padding: 2px;
      border-radius: 4px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    .cell {
      width: 34px;
      height: 38px;
      background: #F5DEB3;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .cell:hover {
      background: #FAEBD7;
    }
    .cell.selected {
      background: #90EE90 !important;
      box-shadow: inset 0 0 10px #32CD32;
    }
    .cell.movable {
      background: #87CEEB !important;
      box-shadow: inset 0 0 8px #4169E1;
    }
    .cell.movable:hover {
      background: #00BFFF !important;
    }
    .cell.can-select {
      box-shadow: inset 0 0 5px #FFD700;
    }
    .cell.last-move {
      background: #FFFACD !important;
    }
    .piece {
      font-size: 1.1rem;
      font-weight: bold;
      color: #1a1a1a;
      text-shadow: 1px 1px 1px rgba(255,255,255,0.5);
    }
    .piece.enemy {
      transform: rotate(180deg);
      color: #8B0000;
    }
    .piece.promoted {
      color: #FF4500;
    }
    .btn {
      padding: 12px 24px;
      font-size: 1rem;
      background: linear-gradient(180deg, #FFD700 0%, #FFA500 100%);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      color: #5D4037;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.1s;
    }
    .btn:hover {
      transform: translateY(-2px);
    }
    .btn:active {
      transform: translateY(0);
    }
    .help-text {
      color: #FFE4B5;
      font-size: 0.85rem;
      text-align: center;
      margin-top: 10px;
      max-width: 320px;
      line-height: 1.5;
    }
    .legend {
      display: flex;
      gap: 15px;
      margin-top: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.8rem;
      color: #fff;
    }
    .legend-box {
      width: 20px;
      height: 20px;
      border-radius: 3px;
    }
    .legend-box.green {
      background: #90EE90;
      box-shadow: inset 0 0 5px #32CD32;
    }
    .legend-box.blue {
      background: #87CEEB;
      box-shadow: inset 0 0 5px #4169E1;
    }
    .legend-box.gold {
      box-shadow: inset 0 0 5px #FFD700;
      background: #F5DEB3;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .modal.show {
      display: flex;
    }
    .modal-content {
      background: #FFEFD5;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    .modal-content h2 {
      color: #5D4037;
      margin-bottom: 15px;
    }
    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    .modal-btn {
      padding: 10px 20px;
      font-size: 1rem;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    }
    .modal-btn.yes {
      background: #FF6347;
      color: white;
    }
    .modal-btn.no {
      background: #4682B4;
      color: white;
    }
  </style>
</head>
<body>
  <h1>ğŸ¯ å°†æ£‹ã‚²ãƒ¼ãƒ </h1>
  <div class="status" id="status">â–² å…ˆæ‰‹ã®ã‚¿ãƒ¼ãƒ³</div>

  <div class="game-container">
    <div class="captured-area enemy" id="enemyCaptured">
      <div class="captured-label">â–³ å¾Œæ‰‹ã®æŒã¡é§’</div>
    </div>

    <div class="board" id="board"></div>

    <div class="captured-area" id="playerCaptured">
      <div class="captured-label">â–² å…ˆæ‰‹ã®æŒã¡é§’</div>
    </div>
  </div>

  <button class="btn" id="reset">ã¯ã˜ã‚ã‹ã‚‰</button>

  <div class="help-text">
    ğŸ’¡ ãƒ’ãƒ³ãƒˆï¼šå…‰ã£ã¦ã„ã‚‹ã‚³ãƒã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸ã¼ã†ï¼<br>
    é’ãå…‰ã‚‹å ´æ‰€ã«å‹•ã‹ã›ã‚‹ã‚ˆï¼
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-box gold"></div>
      <span>å‹•ã‹ã›ã‚‹ã‚³ãƒ</span>
    </div>
    <div class="legend-item">
      <div class="legend-box green"></div>
      <span>é¸ã‚“ã ã‚³ãƒ</span>
    </div>
    <div class="legend-item">
      <div class="legend-box blue"></div>
      <span>å‹•ã‘ã‚‹å ´æ‰€</span>
    </div>
  </div>

  <div class="modal" id="promoteModal">
    <div class="modal-content">
      <h2>æˆã‚Šã¾ã™ã‹ï¼Ÿ</h2>
      <p style="margin-bottom:15px;color:#5D4037;">ã‚³ãƒã‚’ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã§ãã¾ã™ï¼</p>
      <div class="modal-buttons">
        <button class="modal-btn yes" id="promoteYes">æˆã‚‹ï¼</button>
        <button class="modal-btn no" id="promoteNo">ãã®ã¾ã¾</button>
      </div>
    </div>
  </div>

  <div class="modal" id="gameOverModal">
    <div class="modal-content">
      <h2 id="winnerText">å‹ã¡ï¼</h2>
      <div class="modal-buttons">
        <button class="modal-btn yes" id="playAgain">ã‚‚ã†ä¸€åº¦</button>
      </div>
    </div>
  </div>

  <script>
    // é§’ã®ç¨®é¡ã¨è¡¨ç¤ºå
    const PIECES = {
      king: { name: 'ç‹', promoted: null },
      rook: { name: 'é£›', promoted: 'é¾' },
      bishop: { name: 'è§’', promoted: 'é¦¬' },
      gold: { name: 'é‡‘', promoted: null },
      silver: { name: 'éŠ€', promoted: 'å…¨' },
      knight: { name: 'æ¡‚', promoted: 'åœ­' },
      lance: { name: 'é¦™', promoted: 'æ' },
      pawn: { name: 'æ­©', promoted: 'ã¨' }
    };

    // é§’ã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå…ˆæ‰‹åŸºæº–ã€ä¸ŠãŒãƒã‚¤ãƒŠã‚¹ï¼‰
    const MOVES = {
      king: [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]],
      gold: [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,0]],
      silver: [[-1,-1],[-1,0],[-1,1],[1,-1],[1,1]],
      knight: [[-2,-1],[-2,1]],
      pawn: [[-1,0]],
      // æˆã‚Šé§’ã¯é‡‘ã¨åŒã˜å‹•ã
      promoted_silver: [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,0]],
      promoted_knight: [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,0]],
      promoted_lance: [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,0]],
      promoted_pawn: [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,0]]
    };

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let board = [];
    let currentPlayer = 'player'; // player=å…ˆæ‰‹, enemy=å¾Œæ‰‹
    let selectedPiece = null;
    let selectedCaptured = null;
    let capturedPieces = { player: [], enemy: [] };
    let lastMove = null;
    let pendingPromotion = null;

    // åˆæœŸé…ç½®
    function initBoard() {
      board = Array(9).fill(null).map(() => Array(9).fill(null));

      // å¾Œæ‰‹ã®é§’ï¼ˆä¸Šå´ï¼‰
      board[0][0] = { type: 'lance', owner: 'enemy', promoted: false };
      board[0][1] = { type: 'knight', owner: 'enemy', promoted: false };
      board[0][2] = { type: 'silver', owner: 'enemy', promoted: false };
      board[0][3] = { type: 'gold', owner: 'enemy', promoted: false };
      board[0][4] = { type: 'king', owner: 'enemy', promoted: false };
      board[0][5] = { type: 'gold', owner: 'enemy', promoted: false };
      board[0][6] = { type: 'silver', owner: 'enemy', promoted: false };
      board[0][7] = { type: 'knight', owner: 'enemy', promoted: false };
      board[0][8] = { type: 'lance', owner: 'enemy', promoted: false };
      board[1][1] = { type: 'rook', owner: 'enemy', promoted: false };
      board[1][7] = { type: 'bishop', owner: 'enemy', promoted: false };
      for (let i = 0; i < 9; i++) {
        board[2][i] = { type: 'pawn', owner: 'enemy', promoted: false };
      }

      // å…ˆæ‰‹ã®é§’ï¼ˆä¸‹å´ï¼‰
      board[8][0] = { type: 'lance', owner: 'player', promoted: false };
      board[8][1] = { type: 'knight', owner: 'player', promoted: false };
      board[8][2] = { type: 'silver', owner: 'player', promoted: false };
      board[8][3] = { type: 'gold', owner: 'player', promoted: false };
      board[8][4] = { type: 'king', owner: 'player', promoted: false };
      board[8][5] = { type: 'gold', owner: 'player', promoted: false };
      board[8][6] = { type: 'silver', owner: 'player', promoted: false };
      board[8][7] = { type: 'knight', owner: 'player', promoted: false };
      board[8][8] = { type: 'lance', owner: 'player', promoted: false };
      board[7][7] = { type: 'rook', owner: 'player', promoted: false };
      board[7][1] = { type: 'bishop', owner: 'player', promoted: false };
      for (let i = 0; i < 9; i++) {
        board[6][i] = { type: 'pawn', owner: 'player', promoted: false };
      }

      currentPlayer = 'player';
      selectedPiece = null;
      selectedCaptured = null;
      capturedPieces = { player: [], enemy: [] };
      lastMove = null;
      pendingPromotion = null;
    }

    // é§’ã®è¡¨ç¤ºåã‚’å–å¾—
    function getPieceName(piece) {
      const info = PIECES[piece.type];
      if (piece.promoted && info.promoted) {
        return info.promoted;
      }
      return info.name;
    }

    // ç§»å‹•å¯èƒ½ãªä½ç½®ã‚’å–å¾—
    function getValidMoves(row, col, piece) {
      const moves = [];
      const isEnemy = piece.owner === 'enemy';
      const direction = isEnemy ? 1 : -1;

      // é£›è»Šãƒ»é¾ã®å‹•ã
      if (piece.type === 'rook') {
        // ç¸¦æ¨ªã«èµ°ã‚‹
        for (let d of [[-1,0],[1,0],[0,-1],[0,1]]) {
          for (let i = 1; i < 9; i++) {
            const nr = row + d[0] * i;
            const nc = col + d[1] * i;
            if (nr < 0 || nr > 8 || nc < 0 || nc > 8) break;
            if (board[nr][nc]) {
              if (board[nr][nc].owner !== piece.owner) moves.push([nr, nc]);
              break;
            }
            moves.push([nr, nc]);
          }
        }
        // é¾ã¯æ–œã‚1ãƒã‚¹ã‚‚å¯
        if (piece.promoted) {
          for (let d of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
            const nr = row + d[0];
            const nc = col + d[1];
            if (nr >= 0 && nr <= 8 && nc >= 0 && nc <= 8) {
              if (!board[nr][nc] || board[nr][nc].owner !== piece.owner) {
                moves.push([nr, nc]);
              }
            }
          }
        }
        return moves;
      }

      // è§’ãƒ»é¦¬ã®å‹•ã
      if (piece.type === 'bishop') {
        // æ–œã‚ã«èµ°ã‚‹
        for (let d of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
          for (let i = 1; i < 9; i++) {
            const nr = row + d[0] * i;
            const nc = col + d[1] * i;
            if (nr < 0 || nr > 8 || nc < 0 || nc > 8) break;
            if (board[nr][nc]) {
              if (board[nr][nc].owner !== piece.owner) moves.push([nr, nc]);
              break;
            }
            moves.push([nr, nc]);
          }
        }
        // é¦¬ã¯ç¸¦æ¨ª1ãƒã‚¹ã‚‚å¯
        if (piece.promoted) {
          for (let d of [[-1,0],[1,0],[0,-1],[0,1]]) {
            const nr = row + d[0];
            const nc = col + d[1];
            if (nr >= 0 && nr <= 8 && nc >= 0 && nc <= 8) {
              if (!board[nr][nc] || board[nr][nc].owner !== piece.owner) {
                moves.push([nr, nc]);
              }
            }
          }
        }
        return moves;
      }

      // é¦™è»Šã®å‹•ã
      if (piece.type === 'lance') {
        if (piece.promoted) {
          // æˆé¦™ã¯é‡‘ã¨åŒã˜
          for (let d of MOVES.gold) {
            const nr = row + d[0] * direction;
            const nc = col + d[1];
            if (nr >= 0 && nr <= 8 && nc >= 0 && nc <= 8) {
              if (!board[nr][nc] || board[nr][nc].owner !== piece.owner) {
                moves.push([nr, nc]);
              }
            }
          }
        } else {
          // å‰ã«ã¾ã£ã™ã
          for (let i = 1; i < 9; i++) {
            const nr = row + direction * i;
            if (nr < 0 || nr > 8) break;
            if (board[nr][col]) {
              if (board[nr][col].owner !== piece.owner) moves.push([nr, col]);
              break;
            }
            moves.push([nr, col]);
          }
        }
        return moves;
      }

      // ãã®ä»–ã®é§’
      let movePattern;
      if (piece.promoted && piece.type !== 'rook' && piece.type !== 'bishop') {
        movePattern = MOVES.gold; // æˆã‚Šé§’ã¯é‡‘ã¨åŒã˜
      } else {
        movePattern = MOVES[piece.type];
      }

      if (!movePattern) return moves;

      for (let m of movePattern) {
        const nr = row + m[0] * direction;
        const nc = col + m[1];
        if (nr >= 0 && nr <= 8 && nc >= 0 && nc <= 8) {
          if (!board[nr][nc] || board[nr][nc].owner !== piece.owner) {
            moves.push([nr, nc]);
          }
        }
      }

      return moves;
    }

    // æŒã¡é§’ã‚’æ‰“ã¦ã‚‹å ´æ‰€ã‚’å–å¾—
    function getDropMoves(pieceType, owner) {
      const moves = [];
      const isEnemy = owner === 'enemy';

      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c]) continue;

          // æ­©ã¯äºŒæ­©ç¦æ­¢
          if (pieceType === 'pawn') {
            let hasPawn = false;
            for (let row = 0; row < 9; row++) {
              const p = board[row][c];
              if (p && p.type === 'pawn' && !p.promoted && p.owner === owner) {
                hasPawn = true;
                break;
              }
            }
            if (hasPawn) continue;
          }

          // è¡Œãå ´ã®ãªã„é§’ã¯æ‰“ã¦ãªã„
          if (pieceType === 'pawn' || pieceType === 'lance') {
            if ((isEnemy && r === 8) || (!isEnemy && r === 0)) continue;
          }
          if (pieceType === 'knight') {
            if ((isEnemy && r >= 7) || (!isEnemy && r <= 1)) continue;
          }

          moves.push([r, c]);
        }
      }
      return moves;
    }

    // ç›¤é¢ã‚’æç”»
    function render() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';

      // ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå‹•ã‹ã›ã‚‹é§’ã‚’å–å¾—
      const selectablePieces = [];
      if (!pendingPromotion) {
        for (let r = 0; r < 9; r++) {
          for (let c = 0; c < 9; c++) {
            const piece = board[r][c];
            if (piece && piece.owner === currentPlayer) {
              const moves = getValidMoves(r, c, piece);
              if (moves.length > 0) {
                selectablePieces.push(`${r}-${c}`);
              }
            }
          }
        }
      }

      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;

          // æœ€å¾Œã®æ‰‹ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
          if (lastMove && lastMove.to[0] === r && lastMove.to[1] === c) {
            cell.classList.add('last-move');
          }

          // é¸æŠä¸­ã®é§’
          if (selectedPiece && selectedPiece.row === r && selectedPiece.col === c) {
            cell.classList.add('selected');
          }

          // ç§»å‹•å¯èƒ½ãªå ´æ‰€
          if (selectedPiece || selectedCaptured) {
            let validMoves = [];
            if (selectedPiece) {
              const piece = board[selectedPiece.row][selectedPiece.col];
              validMoves = getValidMoves(selectedPiece.row, selectedPiece.col, piece);
            } else if (selectedCaptured) {
              validMoves = getDropMoves(selectedCaptured.type, currentPlayer);
            }
            if (validMoves.some(m => m[0] === r && m[1] === c)) {
              cell.classList.add('movable');
            }
          }

          // é¸æŠå¯èƒ½ãªé§’ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
          if (!selectedPiece && !selectedCaptured && selectablePieces.includes(`${r}-${c}`)) {
            cell.classList.add('can-select');
          }

          const piece = board[r][c];
          if (piece) {
            const pieceEl = document.createElement('span');
            pieceEl.className = 'piece';
            if (piece.owner === 'enemy') pieceEl.classList.add('enemy');
            if (piece.promoted) pieceEl.classList.add('promoted');
            pieceEl.textContent = getPieceName(piece);
            cell.appendChild(pieceEl);
          }

          cell.addEventListener('click', () => handleCellClick(r, c));
          boardEl.appendChild(cell);
        }
      }

      // æŒã¡é§’ã‚’æç”»
      renderCaptured('player');
      renderCaptured('enemy');

      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
      const statusEl = document.getElementById('status');
      statusEl.textContent = currentPlayer === 'player' ? 'â–² å…ˆæ‰‹ã®ã‚¿ãƒ¼ãƒ³' : 'â–³ å¾Œæ‰‹ã®ã‚¿ãƒ¼ãƒ³';
    }

    // æŒã¡é§’ã‚’æç”»
    function renderCaptured(owner) {
      const containerId = owner === 'player' ? 'playerCaptured' : 'enemyCaptured';
      const container = document.getElementById(containerId);
      const label = container.querySelector('.captured-label');
      container.innerHTML = '';
      container.appendChild(label);

      // æŒã¡é§’ã§æ‰“ã¦ã‚‹é§’ã‚’è¨ˆç®—
      const droppablePieces = new Set();
      if (currentPlayer === owner && !selectedPiece && !pendingPromotion) {
        for (const p of capturedPieces[owner]) {
          const moves = getDropMoves(p.type, owner);
          if (moves.length > 0) {
            droppablePieces.add(p.type);
          }
        }
      }

      capturedPieces[owner].forEach((piece, index) => {
        const pieceEl = document.createElement('div');
        pieceEl.className = 'captured-piece';
        if (owner === 'enemy') pieceEl.classList.add('enemy-piece');

        // é¸æŠå¯èƒ½ãªæŒã¡é§’ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        if (droppablePieces.has(piece.type)) {
          pieceEl.style.boxShadow = 'inset 0 0 5px #FFD700';
        }

        // é¸æŠä¸­ã®æŒã¡é§’
        if (selectedCaptured && selectedCaptured.owner === owner && selectedCaptured.index === index) {
          pieceEl.classList.add('selected');
        }

        pieceEl.textContent = PIECES[piece.type].name;
        pieceEl.addEventListener('click', (e) => {
          e.stopPropagation();
          handleCapturedClick(owner, index);
        });
        container.appendChild(pieceEl);
      });
    }

    // ãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯
    function handleCellClick(row, col) {
      if (pendingPromotion) return;

      const piece = board[row][col];

      // æŒã¡é§’ã‚’æ‰“ã¤
      if (selectedCaptured) {
        const validMoves = getDropMoves(selectedCaptured.type, currentPlayer);
        if (validMoves.some(m => m[0] === row && m[1] === col)) {
          // æŒã¡é§’ã‚’æ‰“ã¤
          const captured = capturedPieces[currentPlayer].splice(selectedCaptured.index, 1)[0];
          board[row][col] = { type: captured.type, owner: currentPlayer, promoted: false };
          lastMove = { to: [row, col] };
          selectedCaptured = null;
          switchTurn();
          render();
          checkGameOver();
        } else {
          selectedCaptured = null;
          render();
        }
        return;
      }

      // é§’ã‚’é¸æŠã—ã¦ã„ã‚‹å ´åˆ
      if (selectedPiece) {
        const fromPiece = board[selectedPiece.row][selectedPiece.col];
        const validMoves = getValidMoves(selectedPiece.row, selectedPiece.col, fromPiece);

        // ç§»å‹•å…ˆãŒæœ‰åŠ¹ã‹
        if (validMoves.some(m => m[0] === row && m[1] === col)) {
          // ç›¸æ‰‹ã®é§’ã‚’å–ã‚‹
          if (piece && piece.owner !== currentPlayer) {
            capturedPieces[currentPlayer].push({ type: piece.type, owner: currentPlayer });
          }

          // é§’ã‚’ç§»å‹•
          board[row][col] = fromPiece;
          board[selectedPiece.row][selectedPiece.col] = null;
          lastMove = { from: [selectedPiece.row, selectedPiece.col], to: [row, col] };

          // æˆã‚Šã®åˆ¤å®š
          const canPromote = PIECES[fromPiece.type].promoted && !fromPiece.promoted;
          const isEnemy = fromPiece.owner === 'enemy';
          const inPromoteZone = isEnemy ? (row >= 6 || selectedPiece.row >= 6) : (row <= 2 || selectedPiece.row <= 2);

          // å¼·åˆ¶æˆã‚Šï¼ˆè¡Œãå ´ãŒãªã„ï¼‰
          const mustPromote = !fromPiece.promoted && (
            (fromPiece.type === 'pawn' || fromPiece.type === 'lance') &&
            ((isEnemy && row === 8) || (!isEnemy && row === 0))
          ) || (
            fromPiece.type === 'knight' &&
            ((isEnemy && row >= 7) || (!isEnemy && row <= 1))
          );

          if (mustPromote) {
            fromPiece.promoted = true;
            selectedPiece = null;
            switchTurn();
            render();
            checkGameOver();
          } else if (canPromote && inPromoteZone) {
            // æˆã‚‹ã‹ã©ã†ã‹é¸æŠ
            pendingPromotion = { row, col };
            selectedPiece = null;
            render();
            showPromoteModal();
          } else {
            selectedPiece = null;
            switchTurn();
            render();
            checkGameOver();
          }
        } else if (piece && piece.owner === currentPlayer) {
          // è‡ªåˆ†ã®åˆ¥ã®é§’ã‚’é¸æŠ
          const moves = getValidMoves(row, col, piece);
          if (moves.length > 0) {
            selectedPiece = { row, col };
          } else {
            selectedPiece = null;
          }
          render();
        } else {
          selectedPiece = null;
          render();
        }
      } else {
        // é§’ã‚’é¸æŠ
        if (piece && piece.owner === currentPlayer) {
          const moves = getValidMoves(row, col, piece);
          if (moves.length > 0) {
            selectedPiece = { row, col };
            render();
          }
        }
      }
    }

    // æŒã¡é§’ã‚’ã‚¯ãƒªãƒƒã‚¯
    function handleCapturedClick(owner, index) {
      if (pendingPromotion) return;
      if (owner !== currentPlayer) return;

      const piece = capturedPieces[owner][index];
      const moves = getDropMoves(piece.type, owner);

      if (moves.length > 0) {
        selectedPiece = null;
        selectedCaptured = { owner, index, type: piece.type };
        render();
      }
    }

    // ã‚¿ãƒ¼ãƒ³äº¤ä»£
    function switchTurn() {
      currentPlayer = currentPlayer === 'player' ? 'enemy' : 'player';
    }

    // æˆã‚Šãƒ¢ãƒ¼ãƒ€ãƒ«
    function showPromoteModal() {
      document.getElementById('promoteModal').classList.add('show');
    }

    function hidePromoteModal() {
      document.getElementById('promoteModal').classList.remove('show');
    }

    // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
    function checkGameOver() {
      // ç‹ãŒå–ã‚‰ã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯
      let playerKing = false;
      let enemyKing = false;

      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const piece = board[r][c];
          if (piece && piece.type === 'king') {
            if (piece.owner === 'player') playerKing = true;
            if (piece.owner === 'enemy') enemyKing = true;
          }
        }
      }

      if (!playerKing) {
        showGameOver('â–³ å¾Œæ‰‹ã®å‹ã¡ï¼');
      } else if (!enemyKing) {
        showGameOver('â–² å…ˆæ‰‹ã®å‹ã¡ï¼');
      }
    }

    function showGameOver(message) {
      document.getElementById('winnerText').textContent = message;
      document.getElementById('gameOverModal').classList.add('show');
    }

    function hideGameOver() {
      document.getElementById('gameOverModal').classList.remove('show');
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
    document.getElementById('reset').addEventListener('click', () => {
      initBoard();
      render();
    });

    document.getElementById('promoteYes').addEventListener('click', () => {
      if (pendingPromotion) {
        board[pendingPromotion.row][pendingPromotion.col].promoted = true;
        pendingPromotion = null;
        hidePromoteModal();
        switchTurn();
        render();
        checkGameOver();
      }
    });

    document.getElementById('promoteNo').addEventListener('click', () => {
      pendingPromotion = null;
      hidePromoteModal();
      switchTurn();
      render();
      checkGameOver();
    });

    document.getElementById('playAgain').addEventListener('click', () => {
      hideGameOver();
      initBoard();
      render();
    });

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    initBoard();
    render();
  </script>
</body>
</html>
